# -*- coding: utf-8 -*-
"""knapsack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D_o5a6MnZflHdh5vUfCHYaPH--YPxO9L
"""

def knapsack(maxweight, items):
  """Solves the knapsack problem for the given inputs
  Inputs:
    maxweight (int): the maximum weight the knapsack can hold
    items (list): a list of items from which to choose
    
  Any item in items should be a tuple of the form (weight, value)
  
  Returns:
    solution: the maximum value that can be obtained from the given items with 
    the given weight limit
    taken_items: a list composed of 0's and 1's. A 1 indicates that item was 
    taken, while a zero indicates that item was not taken.
    """
  kh = knapsack_helper(maxweight, items)
  sol = kh.get_solution()
  print(sol)
  return sol[0], [1 if x in sol[1] else 0 for x in items]

def remove_from_list(lis, val):
  # Removes only one instance of the value from the list
  for i in range(len(lis)):
    if lis[i] == val:
      return lis[:i] + lis[i+1:]

  return lis

class knapsack_helper:
  """Helper class to solve the knapsack problem with given inputs"""

  def __init__(self, maxweight, items):
    """Initializes the helper class with the following attributes:
    maxweight (int): the maximum weight the knapsack can hold
    items (list): a list of items from which to choose"""

    self.maxweight = maxweight
    self.items = items

  def get_solution(self):
    """Initializes the recursive process that solves the knapsack problem"""

    initpath = [0, [], self.maxweight, self.items] # the initial path

    def _recurse(path):
      """Recursively solves the knapsack problem"""
      val, taken, mweight, remaining = tuple(path)
      print("recursing...")
      print("Path: ", path)

      # Throw assertion error if maximum weight is negative
      assert mweight >= 0, "mweight is negative"

      def _combine_results(A, B):
        """Combines two paths"""
        print(f"A: {A}", f"B: {B}", sep="\n")
        print(f"Sum: {[A[0] + B[0], A[1]+B[1], B[2], B[3]]}")
        return [A[0] + B[0], A[1]+B[1], B[2], B[3]]

      def _max(paths):
        """Returns path with max value"""
        vals = [path[0] for path in paths]
        m = max(vals)
        for path in paths:
          if path[0] == m:
            return path

      # If no items remain
      if remaining == None:
        return [0, [], mweight, []]

      # If adding any item to the knapsack would exceed the maxweight
      elif mweight < min([x[0] for x in remaining]):
        return [0, [], mweight, []]
      
      # If only one item remains, and that item can be added without exceed maxweight
      elif len(remaining) == 1:
        return [remaining[0][1], [remaining[0]], mweight - remaining[0][0], []]

      # Otherwise
      else:
        choices = []
        for item in remaining:
          choices.append([item[1], [item], mweight - item[0], remove_from_list(remaining, item)]) 
        choices = [choice for choice in choices if choice[2] >= 0]
        return _max([_combine_results(choice, _recurse(choice)) for choice in choices])

    return _recurse(initpath)